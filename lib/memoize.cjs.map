{"version":3,"file":"memoize.cjs","sources":["../src/index.ts"],"sourcesContent":["import { LRUCache } from \"lru-cache\";\nimport Semaphore from \"@chriscdn/promise-semaphore\";\n\ntype Options<T extends any[]> = {\n    ttl?: LRUCache.Milliseconds;\n    max: number;\n    resolver: (...args: T) => string;\n};\n\nconst kDefaultMax = 1000;\n\nconst Memoize = <Args extends any[], Return extends {}>(\n    cb: (...args: Args) => Return,\n    options: Partial<Options<Args>> = {},\n) => {\n    const ttl: number | undefined = options.ttl;\n    const max = options.max ?? kDefaultMax;\n    const resolver = (...args: Args) => JSON.stringify(args);\n\n    const cache = new LRUCache<string, Return>({\n        ttl,\n        max,\n    });\n\n    return (...args: Args): Return => {\n        const key = resolver(...args);\n\n        if (cache.has(key)) {\n            return cache.get(key)!;\n        } else {\n            const returnValue = cb(...args);\n            cache.set(key, returnValue);\n            return returnValue;\n        }\n    };\n};\n\nconst MemoizeAsync = <Args extends any[], Return extends {}>(\n    cb: (...args: Args) => Promise<Return>,\n    options: Partial<Options<Args>> = {},\n) => {\n    const ttl: number | undefined = options.ttl;\n    const max = options.max ?? kDefaultMax;\n    const resolver = (...args: Args) => JSON.stringify(args);\n\n    const semaphore = new Semaphore();\n\n    const cache = new LRUCache<string, Return>({\n        ttl,\n        max,\n    });\n\n    return async (...args: Args): Promise<Return> => {\n        const key = resolver(...args);\n\n        if (cache.has(key)) {\n            return cache.get(key)!;\n        } else {\n            try {\n                await semaphore.acquire(key);\n\n                if (cache.has(key)) {\n                    return cache.get(key)!;\n                } else {\n                    const returnValue = await cb(...args);\n                    cache.set(key, returnValue);\n                    return returnValue;\n                }\n            } finally {\n                semaphore.release(key);\n            }\n        }\n    };\n};\n\nexport { Memoize, MemoizeAsync };\n"],"names":["cb","options","_options$max","max","resolver","JSON","stringify","slice","call","arguments","cache","LRUCache","ttl","args","key","apply","has","get","returnValue","set","_options$max2","semaphore","Semaphore","_arguments","Promise","resolve","acquire","then","_finallyRethrows","_wasThrown","_result","release","e","reject"],"mappings":"gLAWgB,SACZA,EACAC,GACA,IAAAC,OADkC,IAAlCD,IAAAA,EAAkC,CAAA,GAElC,IACME,EAAiB,OAAdD,EAAGD,EAAQE,KAAGD,EAPP,IAQVE,EAAW,WAAH,OAAsBC,KAAKC,UAASC,GAAAA,MAAAC,KAAAC,WAAM,EAElDC,EAAQ,IAAIC,EAAAA,SAAyB,CACvCC,IAL4BX,EAAQW,IAMpCT,IAAAA,IAGJ,OAAO,WAAI,IAAAU,EAAUN,GAAAA,MAAAC,KAAAC,WACXK,EAAMV,EAAQW,aAAIF,GAExB,GAAIH,EAAMM,IAAIF,GACV,OAAOJ,EAAMO,IAAIH,GAEjB,IAAMI,EAAclB,EAAEe,WAAA,EAAIF,GAE1B,OADAH,EAAMS,IAAIL,EAAKI,GACRA,CAEf,CACJ,uBAEqB,SACjBlB,EACAC,GACA,IAAAmB,OADkC,IAAlCnB,IAAAA,EAAkC,CAAE,GAEpC,IAAMW,EAA0BX,EAAQW,IAClCT,EAAiB,OAAdiB,EAAGnB,EAAQE,KAAGiB,EAjCP,IAkCVhB,EAAW,WAAH,OAAsBC,KAAKC,UAAS,GAAAC,MAAAC,KAAAC,WAAM,EAElDY,EAAY,IAAIC,EAAW,QAE3BZ,EAAQ,IAAIC,EAAQA,SAAiB,CACvCC,IAAAA,EACAT,IAAAA,IAGJ,OAAA,WAAA,IAAgDoB,IAA/BV,EAAU,GAAAN,MAAAC,KAAqBC,WACtCK,EAAMV,EAAQW,WAAA,EAAIF,GAAM,OAAAW,QAAAC,QAE1Bf,EAAMM,IAAIF,GACHJ,EAAMO,IAAIH,2BAEbU,QAAAC,QACMJ,EAAUK,QAAQZ,IAAIa,KAExBjB,WAAAA,OAAAA,EAAMM,IAAIF,GACHJ,EAAMO,IAAIH,GAAMU,QAAAC,QAEGzB,EAAEe,WAAIF,EAAAA,IAAKc,KAAA,SAA/BT,GAEN,OADAR,EAAMS,IAAIL,EAAKI,GACRA,CAAY,EAAA,4FAVJU,CAAA,EAYtB,SAAAC,EAAAC,GAC0B,GAAvBT,EAAUU,QAAQjB,GAAKe,EAAAC,MAAAA,EAAAA,OAAAA,CAAA,GAGnC,CAAC,MAAAE,GAAAR,OAAAA,QAAAS,OAAAD,EACL,CAAA,CAAA"}