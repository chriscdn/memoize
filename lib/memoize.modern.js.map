{"version":3,"file":"memoize.modern.js","sources":["../src/index.ts"],"sourcesContent":["import { LRUCache } from \"lru-cache\";\nimport Semaphore from \"@chriscdn/promise-semaphore\";\n\ntype Options<T extends any[]> = {\n    ttl?: LRUCache.Milliseconds;\n    max: number;\n    resolver: (...args: T) => string;\n};\n\nconst kDefaultMax = 1000;\n\nconst Memoize = <Args extends any[], Return extends {}>(\n    cb: (...args: Args) => Return,\n    options: Partial<Options<Args>> = {},\n) => {\n    const ttl: number | undefined = options.ttl;\n    const max = options.max ?? kDefaultMax;\n    const resolver = (...args: Args) => JSON.stringify(args);\n\n    const cache = new LRUCache<string, Return>({\n        ttl,\n        max,\n    });\n\n    return (...args: Args): Return => {\n        const key = resolver(...args);\n\n        if (cache.has(key)) {\n            return cache.get(key)!;\n        } else {\n            const returnValue = cb(...args);\n            cache.set(key, returnValue);\n            return returnValue;\n        }\n    };\n};\n\nconst MemoizeAsync = <Args extends any[], Return extends {}>(\n    cb: (...args: Args) => Promise<Return>,\n    options: Partial<Options<Args>> = {},\n) => {\n    const ttl: number | undefined = options.ttl;\n    const max = options.max ?? kDefaultMax;\n    const resolver = (...args: Args) => JSON.stringify(args);\n\n    const semaphore = new Semaphore();\n\n    const cache = new LRUCache<string, Return>({\n        ttl,\n        max,\n    });\n\n    return async (...args: Args): Promise<Return> => {\n        const key = resolver(...args);\n\n        if (cache.has(key)) {\n            return cache.get(key)!;\n        } else {\n            try {\n                await semaphore.acquire(key);\n\n                if (cache.has(key)) {\n                    return cache.get(key)!;\n                } else {\n                    const returnValue = await cb(...args);\n                    cache.set(key, returnValue);\n                    return returnValue;\n                }\n            } finally {\n                semaphore.release(key);\n            }\n        }\n    };\n};\n\nexport { Memoize, MemoizeAsync };\n"],"names":["Memoize","cb","options","_options$max","max","cache","LRUCache","ttl","args","key","resolver","JSON","stringify","has","get","returnValue","set","MemoizeAsync","_options$max2","semaphore","Semaphore","async","acquire","release"],"mappings":"gFASA,MAEMA,EAAUA,CACZC,EACAC,EAAkC,CAAA,KAClCC,IAAAA,EACA,MACMC,EAAiB,OAAdD,EAAGD,EAAQE,KAAGD,EAPP,IAUVE,EAAQ,IAAIC,EAAyB,CACvCC,IAL4BL,EAAQK,IAMpCH,QAGJ,MAAO,IAAII,KACP,MAAMC,EAROC,KAAIF,IAAeG,KAAKC,UAAUJ,GAQnCE,IAAYF,GAExB,GAAIH,EAAMQ,IAAIJ,GACV,OAAOJ,EAAMS,IAAIL,GACd,CACH,MAAMM,EAAcd,KAAMO,GAE1B,OADAH,EAAMW,IAAIP,EAAKM,GACRA,CACV,EACL,EAGEE,EAAeA,CACjBhB,EACAC,EAAkC,CAAE,KACpC,IAAAgB,EACA,MAAMX,EAA0BL,EAAQK,IAClCH,EAAiBc,OAAdA,EAAGhB,EAAQE,KAAGc,EAjCP,IAoCVC,EAAY,IAAIC,EAEhBf,EAAQ,IAAIC,EAAyB,CACvCC,MACAH,QAGJ,OAAciB,SAAGb,KACb,MAAMC,EAVOC,KAAIF,IAAeG,KAAKC,UAAUJ,GAUnCE,IAAYF,GAExB,GAAIH,EAAMQ,IAAIJ,GACV,OAAOJ,EAAMS,IAAIL,GAEjB,IAGI,SAFMU,EAAUG,QAAQb,GAEpBJ,EAAMQ,IAAIJ,GACV,OAAOJ,EAAMS,IAAIL,GACd,CACH,MAAMM,QAAoBd,KAAMO,GAEhC,OADAH,EAAMW,IAAIP,EAAKM,GACRA,CACV,CACJ,CAAA,QACGI,EAAUI,QAAQd,EACrB,CACJ,CACL"}